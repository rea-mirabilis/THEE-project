N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
#  offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
#  offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
#  offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
#  offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
#  offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
# Apply decay and selection coefficients for each genotype draw with rbinom
#  offsp_RRRR <- rbinom(1, size = N_RRRR_new, prob = (1 - decay_rate + sel_coeffs[1]))
#  offsp_RRRr <- rbinom(1, size = N_RRRr_new, prob = (1 - decay_rate + sel_coeffs[2]))
#  offsp_RRrr <- rbinom(1, size = N_RRrr_new, prob = (1 - decay_rate + sel_coeffs[3]))
#  offsp_Rrrr <- rbinom(1, size = N_Rrrr_new, prob = (1 - decay_rate + sel_coeffs[4]))
#  offsp_rrrr <- rbinom(1, size = N_rrrr_new, prob = (1 - decay_rate + sel_coeffs[5]))
#ifelse rbinom
offsp_RRRR <- ifelse(N_RRRR_new > 0 && (1 - decay_rate + sel_coeffs[1]) >= 0 && (1 - decay_rate + sel_coeffs[1]) <= 1,
rbinom(1, size = N_RRRR_new, prob = (1 - decay_rate + sel_coeffs[1])), 0)
offsp_RRRr <- ifelse(N_RRRr_new > 0 && (1 - decay_rate + sel_coeffs[2]) >= 0 && (1 - decay_rate + sel_coeffs[2]) <= 1,
rbinom(1, size = N_RRRr_new, prob = (1 - decay_rate + sel_coeffs[2])), 0)
offsp_RRrr <- ifelse(N_RRrr_new > 0 && (1 - decay_rate + sel_coeffs[3]) >= 0 && (1 - decay_rate + sel_coeffs[3]) <= 1,
rbinom(1, size = N_RRrr_new, prob = (1 - decay_rate + sel_coeffs[3])), 0)
offsp_Rrrr <- ifelse(N_Rrrr_new > 0 && (1 - decay_rate + sel_coeffs[4]) >= 0 && (1 - decay_rate + sel_coeffs[4]) <= 1,
rbinom(1, size = N_Rrrr_new, prob = (1 - decay_rate + sel_coeffs[4])), 0)
offsp_rrrr <- ifelse(N_rrrr_new > 0 && (1 - decay_rate + sel_coeffs[5]) >= 0 && (1 - decay_rate + sel_coeffs[5]) <= 1,
rbinom(1, size = N_rrrr_new, prob = (1 - decay_rate + sel_coeffs[5])), 0)
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR, N_RRRr, N_RRrr, N_Rrrr, N_rrrr, decay_rate, sel_coeffs, mut_rate) {
# Mutations between genotypes (mutations from R to r, and vice versa)
mut_RRRR_to_RRRr <- rpois(1, N_RRRR * mut_rate)  # RRRR individuals mutate into RRRr
mut_RRRr_to_RRRR <- rpois(1, N_RRRR * mut_rate)  # RRRr individuals mutate into RRRR
mut_RRRr_to_RRrr <- rpois(1, N_RRRr * mut_rate)  # RRRr individuals mutate into RRrr
mut_RRrr_to_Rrrr <- rpois(1, N_RRrr * mut_rate)  # RRrr individuals mutate into Rrrr
mut_Rrrr_to_RRrr <- rpois(1, N_Rrrr * mut_rate)  # Rrrr individuals mutate into RRrr
mut_rrrr_to_Rrrr <- rpois(1, N_rrrr * mut_rate)  # rrrr individuals mutate into Rrrr
# HERE, I am not sure which mutations should I consider, should it be like everyone can mutate to their neighbor or only some types of mutations?
# Update population sizes based on mutations and offspring survival
N_RRRR_new <- max(N_RRRR + mut_RRRr_to_RRRR - mut_RRRR_to_RRRr, 0)
N_RRRr_new <- max(N_RRRr + mut_RRRR_to_RRRr - mut_RRRr_to_RRrr, 0)
N_RRrr_new <- max(N_RRrr + mut_Rrrr_to_RRrr - mut_RRrr_to_Rrrr, 0)
N_Rrrr_new <- max(N_Rrrr + mut_RRrr_to_Rrrr - mut_Rrrr_to_RRrr, 0)
N_rrrr_new <- max(N_rrrr - mut_rrrr_to_Rrrr, 0)
# call the mating function for creating offspring
mating_function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate)
}
# setting the numbers of the initial population
Init_RRRR = 100
Init_RRRr = 100
Init_RRrr = 100
Init_Rrrr = 100
Init_rrrr = 100
# test the function
print(simulate_one_gen_tetraploid(Init_RRRR, Init_RRRr, Init_RRrr, Init_Rrrr, Init_rrrr, 0.01, sel_coeffs, 0.01))
### variables and parameters for diploid population
#Variables:
#N_RRRR_new = Number of RRRR individuals (>=0)
#N_RRRr_new = Number of RRRr individuals (>=0)
#N_RRrr_new = Number of RRrr individuals (>=0)
#N_Rrrr_new = Number of Rrrr individuals (>=0)
#N_rrrr_new = Number of rrrr individuals (>=0)
#number of generations
#Parameters:
#N_RRRR = initial number of RRRR individuals(>=0)
#N_RRRr = initial number of RRRr individuals(>=0)
#N_RRrr = initial number of RRrr individuals(>=0)
#N_Rrrr = initial number of Rrrr individuals(>=0)
#N_rrrr = initial number of rrrr individuals(>=0)
#decay_rate = power of herbicide application to kill individuals (>0 to have potential extinction)
#sel_coeffs = selective advantage of the genotypes over others. (has to be between 0 and 1) for 0.01 = low fitness, 0,2 = intermediate fitness,  0.5 = high fitness (should be bigger than decay rate for evolutionary rescue likelyness)
#mut_rate = mutation rate (>=0)
# Function to simulate random mating for tetraploid genotypes
mating_function <- function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate){
#computing total new population
total_new = N_RRRR_new + N_RRRr_new + N_RRrr_new + N_Rrrr_new + N_rrrr_new
freq_p = (N_RRRR_new * 4 + N_RRRr_new * 3 + N_RRrr_new * 2 + N_Rrrr_new )/ (4 * total_new)
freq_q = 1 - freq_p
#hardy weinberg random mating
freq_RRRR <- (freq_p^4)
freq_RRRr <- (4 * freq_p^3 * freq_q)
freq_RRrr <- (6 * freq_p^2 * freq_q^2)
freq_Rrrr <- (4 * freq_q^3 * freq_p)
freq_rrrr <- (freq_q^4)
#return to "expected" by multiplying freq with the pops
offspring_total <- total_new
N_RRRR_new <- freq_RRRR * total_new
N_RRRr_new <- freq_RRRr * total_new
N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
# Apply decay and selection coefficients for each genotype draw with rbinom
#  offsp_RRRR <- rbinom(1, size = N_RRRR_new, prob = (1 - decay_rate + sel_coeffs[1]))
#  offsp_RRRr <- rbinom(1, size = N_RRRr_new, prob = (1 - decay_rate + sel_coeffs[2]))
#  offsp_RRrr <- rbinom(1, size = N_RRrr_new, prob = (1 - decay_rate + sel_coeffs[3]))
#  offsp_Rrrr <- rbinom(1, size = N_Rrrr_new, prob = (1 - decay_rate + sel_coeffs[4]))
#  offsp_rrrr <- rbinom(1, size = N_rrrr_new, prob = (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR, N_RRRr, N_RRrr, N_Rrrr, N_rrrr, decay_rate, sel_coeffs, mut_rate) {
# Mutations between genotypes (mutations from R to r, and vice versa)
mut_RRRR_to_RRRr <- rpois(1, N_RRRR * mut_rate)  # RRRR individuals mutate into RRRr
mut_RRRr_to_RRRR <- rpois(1, N_RRRR * mut_rate)  # RRRr individuals mutate into RRRR
mut_RRRr_to_RRrr <- rpois(1, N_RRRr * mut_rate)  # RRRr individuals mutate into RRrr
mut_RRrr_to_Rrrr <- rpois(1, N_RRrr * mut_rate)  # RRrr individuals mutate into Rrrr
mut_Rrrr_to_RRrr <- rpois(1, N_Rrrr * mut_rate)  # Rrrr individuals mutate into RRrr
mut_rrrr_to_Rrrr <- rpois(1, N_rrrr * mut_rate)  # rrrr individuals mutate into Rrrr
# HERE, I am not sure which mutations should I consider, should it be like everyone can mutate to their neighbor or only some types of mutations?
# Update population sizes based on mutations and offspring survival
N_RRRR_new <- max(N_RRRR + mut_RRRr_to_RRRR - mut_RRRR_to_RRRr, 0)
N_RRRr_new <- max(N_RRRr + mut_RRRR_to_RRRr - mut_RRRr_to_RRrr, 0)
N_RRrr_new <- max(N_RRrr + mut_Rrrr_to_RRrr - mut_RRrr_to_Rrrr, 0)
N_Rrrr_new <- max(N_Rrrr + mut_RRrr_to_Rrrr - mut_Rrrr_to_RRrr, 0)
N_rrrr_new <- max(N_rrrr - mut_rrrr_to_Rrrr, 0)
# call the mating function for creating offspring
mating_function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate)
}
# setting the numbers of the initial population
Init_RRRR = 100
Init_RRRr = 100
Init_RRrr = 100
Init_Rrrr = 100
Init_rrrr = 100
# test the function
print(simulate_one_gen_tetraploid(Init_RRRR, Init_RRRr, Init_RRrr, Init_Rrrr, Init_rrrr, 0.01, sel_coeffs, 0.01))
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
set.seed(123)
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
set.seed(1300)
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
set.seed(1300)
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
### variables and parameters for diploid population
#Variables:
#N_RRRR_new = Number of RRRR individuals (>=0)
#N_RRRr_new = Number of RRRr individuals (>=0)
#N_RRrr_new = Number of RRrr individuals (>=0)
#N_Rrrr_new = Number of Rrrr individuals (>=0)
#N_rrrr_new = Number of rrrr individuals (>=0)
#number of generations
#Parameters:
#N_RRRR = initial number of RRRR individuals(>=0)
#N_RRRr = initial number of RRRr individuals(>=0)
#N_RRrr = initial number of RRrr individuals(>=0)
#N_Rrrr = initial number of Rrrr individuals(>=0)
#N_rrrr = initial number of rrrr individuals(>=0)
#decay_rate = power of herbicide application to kill individuals (>0 to have potential extinction)
#sel_coeffs = selective advantage of the genotypes over others. (has to be between 0 and 1) for 0.01 = low fitness, 0,2 = intermediate fitness,  0.5 = high fitness (should be bigger than decay rate for evolutionary rescue likelyness)
#mut_rate = mutation rate (>=0)
# Function to simulate random mating for tetraploid genotypes
mating_function <- function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate){
#computing total new population
total_new <- N_RRRR_new + N_RRRr_new + N_RRrr_new + N_Rrrr_new + N_rrrr_new
freq_p <- (N_RRRR_new * 4 + N_RRRr_new * 3 + N_RRrr_new * 2 + N_Rrrr_new * 1) / (4 * total_new)
freq_q <- 1 - freq_p
#hardy weinberg random mating
freq_RRRR <- (freq_p^4)
freq_RRRr <- (4 * freq_p^3 * freq_q)
freq_RRrr <- (6 * freq_p^2 * freq_q^2)
freq_Rrrr <- (4 * freq_q^3 * freq_p)
freq_rrrr <- (freq_q^4)
#return to "expected" by multiplying freq with the pops
offspring_total <- total_new
N_RRRR_new <- freq_RRRR * total_new
N_RRRr_new <- freq_RRRr * total_new
N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
# Apply decay and selection coefficients for each genotype draw with rbinom
#  offsp_RRRR <- rbinom(1, size = N_RRRR_new, prob = (1 - decay_rate + sel_coeffs[1]))
#  offsp_RRRr <- rbinom(1, size = N_RRRr_new, prob = (1 - decay_rate + sel_coeffs[2]))
#  offsp_RRrr <- rbinom(1, size = N_RRrr_new, prob = (1 - decay_rate + sel_coeffs[3]))
#  offsp_Rrrr <- rbinom(1, size = N_Rrrr_new, prob = (1 - decay_rate + sel_coeffs[4]))
#  offsp_rrrr <- rbinom(1, size = N_rrrr_new, prob = (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR, N_RRRr, N_RRrr, N_Rrrr, N_rrrr, decay_rate, sel_coeffs, mut_rate) {
# Mutations between genotypes (mutations from R to r, and vice versa)
mut_RRRR_to_RRRr <- rpois(1, N_RRRR * mut_rate)  # RRRR individuals mutate into RRRr
mut_RRRr_to_RRRR <- rpois(1, N_RRRR * mut_rate)  # RRRr individuals mutate into RRRR
mut_RRRr_to_RRrr <- rpois(1, N_RRRr * mut_rate)  # RRRr individuals mutate into RRrr
mut_RRrr_to_Rrrr <- rpois(1, N_RRrr * mut_rate)  # RRrr individuals mutate into Rrrr
mut_Rrrr_to_RRrr <- rpois(1, N_Rrrr * mut_rate)  # Rrrr individuals mutate into RRrr
mut_rrrr_to_Rrrr <- rpois(1, N_rrrr * mut_rate)  # rrrr individuals mutate into Rrrr
# HERE, I am not sure which mutations should I consider, should it be like everyone can mutate to their neighbor or only some types of mutations?
# Update population sizes based on mutations and offspring survival
N_RRRR_new <- max(N_RRRR + mut_RRRr_to_RRRR - mut_RRRR_to_RRRr, 0)
N_RRRr_new <- max(N_RRRr + mut_RRRR_to_RRRr - mut_RRRr_to_RRrr, 0)
N_RRrr_new <- max(N_RRrr + mut_Rrrr_to_RRrr - mut_RRrr_to_Rrrr, 0)
N_Rrrr_new <- max(N_Rrrr + mut_RRrr_to_Rrrr - mut_Rrrr_to_RRrr, 0)
N_rrrr_new <- max(N_rrrr - mut_rrrr_to_Rrrr, 0)
# call the mating function for creating offspring
mating_function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate)
}
# setting the numbers of the initial population
Init_RRRR = 100
Init_RRRr = 100
Init_RRrr = 100
Init_Rrrr = 100
Init_rrrr = 100
# test the function
print(simulate_one_gen_tetraploid(Init_RRRR, Init_RRRr, Init_RRrr, Init_Rrrr, Init_rrrr, 0.01, sel_coeffs, 0.01))
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.1, 0.2, 0.1, 0.01)
mut_rate <- 0.00001
t_max <- 10
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
# Create a matrix to save population results
pop_matrix <- matrix(0, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1.5 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Parameters
decay_rate <- 0.01
sel_coeffs <- c(0.01, 0.3, 0.5, 0.3, 0.01)
mut_rate <- 0.001
t_max <- 10
# Initial population sizes for each genotype
N_init_RRRR <- 100
N_init_RRRr <- 100
N_init_RRrr <- 100
N_init_Rrrr <- 100
N_init_rrrr <- 100
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
