freq_rr <- freq_q^2
#return to "expected" by multiplying freq with the pops
N_RR <- freq_RR * total
N_Rr <- freq_Rr * total
N_rr <- freq_rr * total
# Apply decay and selection coefficients for each genotype
offsp_RR <- rpois(1, N_RR * (1 - decay_rate + sel_coeffs[1]))
offsp_Rr <- rpois(1, N_Rr * (1 - decay_rate + sel_coeffs[3]))
offsp_rr <- rpois(1, N_rr * (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RR, offsp_Rr, offsp_rr))
}
#test the function
print(simulate_one_gen_diploid(N_RR=0, N_Rr=0, N_rr=100, 0.1, c(0,0.1,0.2,0.1,0), 0.01))
simulate_pop_diploid <- function(N_RR, N_Rr, N_rr, decay_rate, sel_coeffs, mut_rate,t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_RR, N_Rr, N_rr)
# initiate the variables
pop_new <- c(N_RR, N_Rr, N_rr)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen_diploid(pop_new[1],pop_new[2],pop_new[3], decay_rate, sel_coeffs, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3] >= 5*(init_RR + init_Rr + init_rr) | pop_new[1]+pop_new[2]+ pop_new[3]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("RR","Rr","rr")
# return the result
return(pop_vector)
}
output <- simulate_pop_diploid(N_RR = 0, N_Rr=0, N_rr=1000, decay_rate=0.175, sel_coeffs, mut_rate=0.05,max_gen = 100)
simulate_pop_diploid <- function(N_RR, N_Rr, N_rr, decay_rate, sel_coeffs, mut_rate,t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_RR, N_Rr, N_rr)
# initiate the variables
pop_new <- c(N_RR, N_Rr, N_rr)
#take the values of initial variables
init_RR <- N_RR
init_Rr <- N_Rr
init_rr <- N_rr
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen_diploid(pop_new[1],pop_new[2],pop_new[3], decay_rate, sel_coeffs, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3] >= 5*(init_RR + init_Rr + init_rr) | pop_new[1]+pop_new[2]+ pop_new[3]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("RR","Rr","rr")
# return the result
return(pop_vector)
}
output <- simulate_pop_diploid(N_RR = 0, N_Rr=0, N_rr=1000, decay_rate=0.175, sel_coeffs = c(0,0.1,0.2,0.1,0), mut_rate=0.05,t_max = 100)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[,3],type='l',ylim=c(0,max(output[,1]+output[,2]+ output[,3])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
lines(x_range,output[,3], col="green")
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate, sel_coeffs, mut_rate) {
#computing total new population
total_new <- N_RRRR_new + N_RRRr_new + N_RRrr_new + N_Rrrr_new + N_rrrr_new
#calculate just the total gamete R and r
total_R <- (N_RRRR_new * 4 + N_RRRr_new * 3 + N_RRrr_new * 2 + N_Rrrr_new * 1)
total_r <- (N_rrrr_new * 4 + N_Rrrr_new * 3 + N_RRrr_new * 2 + N_RRRr_new * 1)
#and apply the mutation rate and then do the division
mut_r_to_R <- rpois(1, total_r * mut_rate)
total_R_aftermut <- max(total_R + mut_r_to_R, 0)
total_r_aftermut <- max(total_r - mut_r_to_R, 0)
freq_p <- total_R_aftermut / (4 * total_new)
freq_q <- total_r_aftermut / (4 * total_new)
#hardy weinberg random mating
freq_RRRR <- (freq_p^4)
freq_RRRr <- (4 * freq_p^3 * freq_q)
freq_RRrr <- (6 * freq_p^2 * freq_q^2)
freq_Rrrr <- (4 * freq_q^3 * freq_p)
freq_rrrr <- (freq_q^4)
#return to "expected" by multiplying freq with the pops
offspring_total <- total_new
N_RRRR_new <- freq_RRRR * total_new
N_RRRr_new <- freq_RRRr * total_new
N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# setting the numbers of the initial population
Init_RRRR = 100
Init_RRRr = 100
Init_RRrr = 100
Init_Rrrr = 100
Init_rrrr = 100
# test the function
print(simulate_one_gen_tetraploid(Init_RRRR, Init_RRRr, Init_RRrr, Init_Rrrr, Init_rrrr, 0.01, sel_coeffs, 0.01))
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate, sel_coeffs, mut_rate) {
#computing total new population
total_new <- N_RRRR_new + N_RRRr_new + N_RRrr_new + N_Rrrr_new + N_rrrr_new
#calculate just the total gamete R and r
total_R <- (N_RRRR_new * 4 + N_RRRr_new * 3 + N_RRrr_new * 2 + N_Rrrr_new * 1)
total_r <- (N_rrrr_new * 4 + N_Rrrr_new * 3 + N_RRrr_new * 2 + N_RRRr_new * 1)
#and apply the mutation rate and then do the division
mut_r_to_R <- rpois(1, total_r * mut_rate)
total_R_aftermut <- max(total_R + mut_r_to_R, 0)
total_r_aftermut <- max(total_r - mut_r_to_R, 0)
freq_p <- total_R_aftermut / (4 * total_new)
freq_q <- total_r_aftermut / (4 * total_new)
#hardy weinberg random mating
freq_RRRR <- (freq_p^4)
freq_RRRr <- (4 * freq_p^3 * freq_q)
freq_RRrr <- (6 * freq_p^2 * freq_q^2)
freq_Rrrr <- (4 * freq_q^3 * freq_p)
freq_rrrr <- (freq_q^4)
#return to "expected" by multiplying freq with the pops
offspring_total <- total_new
N_RRRR_new <- freq_RRRR * total_new
N_RRRr_new <- freq_RRRr * total_new
N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# test the function
print(simulate_one_gen_tetraploid(Init_RRRR = 0, Init_RRRr = 0, Init_RRrr = 0, Init_Rrrr = 0, Init_rrrr = 1000, 0.01, sel_coeffs = c(0,0.1,0.2,0.1,0), 0.01))
# setting the selective coeff of each genotype, order of RRRR RRRr RRrr Rrrr rrrr
#sel_coeffs = c(0.01,0.5,0.8,0.5,0.01)
# Function to simulate one generation for tetraploid genotypes
simulate_one_gen_tetraploid <- function(N_RRRR_new, N_RRRr_new, N_RRrr_new, N_Rrrr_new, N_rrrr_new, decay_rate, sel_coeffs, mut_rate) {
#computing total new population
total_new <- N_RRRR_new + N_RRRr_new + N_RRrr_new + N_Rrrr_new + N_rrrr_new
#calculate just the total gamete R and r
total_R <- (N_RRRR_new * 4 + N_RRRr_new * 3 + N_RRrr_new * 2 + N_Rrrr_new * 1)
total_r <- (N_rrrr_new * 4 + N_Rrrr_new * 3 + N_RRrr_new * 2 + N_RRRr_new * 1)
#and apply the mutation rate and then do the division
mut_r_to_R <- rpois(1, total_r * mut_rate)
total_R_aftermut <- max(total_R + mut_r_to_R, 0)
total_r_aftermut <- max(total_r - mut_r_to_R, 0)
freq_p <- total_R_aftermut / (4 * total_new)
freq_q <- total_r_aftermut / (4 * total_new)
#hardy weinberg random mating
freq_RRRR <- (freq_p^4)
freq_RRRr <- (4 * freq_p^3 * freq_q)
freq_RRrr <- (6 * freq_p^2 * freq_q^2)
freq_Rrrr <- (4 * freq_q^3 * freq_p)
freq_rrrr <- (freq_q^4)
#return to "expected" by multiplying freq with the pops
offspring_total <- total_new
N_RRRR_new <- freq_RRRR * total_new
N_RRRr_new <- freq_RRRr * total_new
N_RRrr_new <- freq_RRrr * total_new
N_Rrrr_new <- freq_Rrrr * total_new
N_rrrr_new <- freq_rrrr * total_new
# Apply decay and selection coefficients for each genotype draw with rpois
offsp_RRRR <- rpois(1, N_RRRR_new * (1 - decay_rate + sel_coeffs[1]))
offsp_RRRr <- rpois(1, N_RRRr_new * (1 - decay_rate + sel_coeffs[2]))
offsp_RRrr <- rpois(1, N_RRrr_new * (1 - decay_rate + sel_coeffs[3]))
offsp_Rrrr <- rpois(1, N_Rrrr_new * (1 - decay_rate + sel_coeffs[4]))
offsp_rrrr <- rpois(1, N_rrrr_new * (1 - decay_rate + sel_coeffs[5]))
return(c(offsp_RRRR, offsp_RRRr, offsp_RRrr, offsp_Rrrr, offsp_rrrr))
}
# test the function
print(simulate_one_gen_tetraploid(N_RRRR_new = 0, N_RRRr_new = 0, N_RRrr_new = 0, N_Rrrr_new = 0, N_rrrr_new = 1000, 0.01, sel_coeffs = c(0,0.1,0.2,0.1,0), 0.01))
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
#  #call sell_coeffs from the table
#  for (i in 1:nrow(sel_coeffs_table)) {
#  sel_coeffs <- sel_coeffs_table[i, ]
#  }
# Create a matrix to save population results
pop_matrix <- matrix(NA, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1000 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR = 0, N_init_RRRr = 0, N_init_RRrr = 0, N_init_Rrrr = 0, N_init_rrrr = 1000, decay_rate = 0.17, sel_coeffsc(0,0.1,0.2,0.1,0), mut_rate = 0.001, t_max = 100)
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
#  #call sell_coeffs from the table
#  for (i in 1:nrow(sel_coeffs_table)) {
#  sel_coeffs <- sel_coeffs_table[i, ]
#  }
# Create a matrix to save population results
pop_matrix <- matrix(NA, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1000 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR = 0, N_init_RRRr = 0, N_init_RRrr = 0, N_init_Rrrr = 0, N_init_rrrr = 1000, decay_rate = 0.17, sel_coeffs = c(0,0.1,0.2,0.1,0), mut_rate = 0.001, t_max = 100)
print(pop_result)
# Plot the results
x_range <- 0:(nrow(pop_result) - 1)
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
# Function to simulate multiple generations for tetraploid genotypes
simulate_pop_tetraploid <- function(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr, decay_rate, sel_coeffs, mut_rate, t_max) {
#  #call sell_coeffs from the table
#  for (i in 1:nrow(sel_coeffs_table)) {
#  sel_coeffs <- sel_coeffs_table[i, ]
#  }
# Create a matrix to save population results
pop_matrix <- matrix(NA, nrow = t_max + 1, ncol = 5)
colnames(pop_matrix) <- c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr")
pop_matrix[1,] <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Initialize the population for the first generation
pop_current <- c(N_init_RRRR, N_init_RRRr, N_init_RRrr, N_init_Rrrr, N_init_rrrr)
# Run the simulation for t_max generations
for (t in 1:t_max) {
pop_next <- simulate_one_gen_tetraploid(pop_current[1], pop_current[2], pop_current[3], pop_current[4], pop_current[5], decay_rate, sel_coeffs, mut_rate)
pop_matrix[t + 1,] <- pop_next
pop_current <- pop_next
# Early stop condition: if population drops to zero or exceeds a threshold
if (sum(pop_next) == 0 || sum(pop_next) >= 1000 * sum(pop_matrix[1,])) {
break
}
}
return(pop_matrix)
}
# Run the simulation and store the output
pop_result <- simulate_pop_tetraploid(N_init_RRRR = 0, N_init_RRRr = 0, N_init_RRrr = 0, N_init_Rrrr = 0, N_init_rrrr = 1000, decay_rate = 0.17, sel_coeffs = c(0,0.1,0.2,0.1,0), mut_rate = 0.001, t_max = 100)
print(pop_result)
# Plot the results
#x_range <- 0:(nrow(pop_result) - 1)
#plot(x_range, rowSums(pop_result), type='l', ylim=c(0, max(rowSums(pop_result))), xlab="Generation", ylab="Population Size", col="black")
#lines(x_range, pop_result[,1], col="blue", lty=1)  # RRRR
#lines(x_range, pop_result[,2], col="red", lty=2)   # RRRr
#lines(x_range, pop_result[,3], col="green", lty=3) # RRrr
#lines(x_range, pop_result[,4], col="purple", lty=4)# Rrrr
#lines(x_range, pop_result[,5], col="orange", lty=5)# rrrr
#legend("topright", legend=c("RRRR", "RRRr", "RRrr", "Rrrr", "rrrr"), col=c("blue", "red", "green", "purple", "orange"), lty=1:5)
create_sel_coeffs <- function(s_number, biggest_S, inc) {
sel_coeffs_table <- matrix(0, nrow = s_number + 1, ncol = 5)
colnames(sel_coeffs_table) <- c("sc_low", "sc_medium", "sc_high", "sc_medium", "sc_low")
s <- 0.15
sc_current <- c(0,s/2, s ,s/2, 0)
# Run the table creation
for (i in 1:s_number + 1) {
sc_next <- c(0,s/2, s ,s/2, 0)
sel_coeffs_table[i,] <- sc_next
sc_current <- sc_next
#growing s by increment(inc) we set until it's too big
if (s <= biggest_S) {
s <- (s + inc)
}
}
return(sel_coeffs_table)
}
print(create_sel_coeffs(s_number = 20, biggest_S = 3, inc = 0.05))
#create the table to use later
seltable <- create_sel_coeffs(s_number = 20, biggest_S = 3, inc = 0.05)
print(seltable[3,])
#the down you go in the table the more heterozygote advantage you have.
# set some parameters to fixed values
init_RRRR <- 0
init_RRRr <- 0
init_RRrr <- 0
init_Rrrr <- 0
init_rrrr <- 250
m_rate <- 0.01
max_gen <- 100
decay_rate <- 0.155
# determine how often to run the simulation for each set of parameters
replicates <- 50
#call the seltable here.
seltable <- create_sel_coeffs(s_number = 42, biggest_S = 3, inc = 0.005)
print(seltable)
# initialize vector - where to collect the probablitys
pr <- numeric(nrow(seltable))
# run the simulation across all chosen parameters
# loop over sel coefs tetraploid
for(i in 1:nrow(seltable)){
# loop over selection coefficients
sel_coeffs <- seltable[i, ]
j<-1
success <- 0
repeat {
j <- j+1
# increase counter by one
# run the simulation once
first_run <- simulate_pop_tetraploid(init_RRRR, init_RRRr, init_RRrr, init_Rrrr, init_rrrr, decay_rate, sel_coeffs, mut_rate, max_gen)
#complete cases to not take N/As we generated to fill the matrix
first_run_with_numbers <- first_run[complete.cases(first_run),]
#calculating total population size in the end
total_pop_in_the_end <- sum(as.numeric(first_run_with_numbers[nrow(first_run_with_numbers),]))
# determine if the population survived
if(total_pop_in_the_end != 0) {
success <- success + 1
}
pr[i] = success/replicates
if(j>=replicates) break
}
}
# set some parameters to fixed values
init_RRRR <- 0
init_RRRr <- 0
init_RRrr <- 0
init_Rrrr <- 0
init_rrrr <- 250
mut_rate <- 0.01
max_gen <- 100
decay_rate <- 0.155
# determine how often to run the simulation for each set of parameters
replicates <- 50
#call the seltable here.
seltable <- create_sel_coeffs(s_number = 42, biggest_S = 3, inc = 0.005)
print(seltable)
# initialize vector - where to collect the probablitys
pr <- numeric(nrow(seltable))
# run the simulation across all chosen parameters
# loop over sel coefs tetraploid
for(i in 1:nrow(seltable)){
# loop over selection coefficients
sel_coeffs <- seltable[i, ]
j<-1
success <- 0
repeat {
j <- j+1
# increase counter by one
# run the simulation once
first_run <- simulate_pop_tetraploid(init_RRRR, init_RRRr, init_RRrr, init_Rrrr, init_rrrr, decay_rate, sel_coeffs, mut_rate, max_gen)
#complete cases to not take N/As we generated to fill the matrix
first_run_with_numbers <- first_run[complete.cases(first_run),]
#calculating total population size in the end
total_pop_in_the_end <- sum(as.numeric(first_run_with_numbers[nrow(first_run_with_numbers),]))
# determine if the population survived
if(total_pop_in_the_end != 0) {
success <- success + 1
}
pr[i] = success/replicates
if(j>=replicates) break
}
}
print(pr)
init_RR = 0
init_Rr = 0
init_rr = 250
pr_diploid <- numeric(nrow(seltable))
replicates_diploid <- 50
for(k in 1:nrow(seltable)){
# loop over selection coefficients
sel_coeffs <- seltable[k, ]
l<-1
success_diploid <- 0
repeat {
l <- l+1
# increase counter by one
# run the simulation once
first_run_diploid <- simulate_pop_diploid(init_RR, init_Rr, init_rr, decay_rate, sel_coeffs, mut_rate, max_gen)
#complete cases to not take N/As we generated to fill the matrix
first_run_with_numbers_diploid <- first_run_diploid[complete.cases(first_run_diploid),]
#calculating total population size in the end
total_pop_in_the_end_diploid <- sum(as.numeric(first_run_with_numbers_diploid[nrow(first_run_with_numbers_diploid),]))
# determine if the population survived
if(total_pop_in_the_end_diploid != 0) {
success_diploid <- success_diploid + 1
}
pr_diploid[k] = success_diploid/replicates_diploid
if(l>=replicates_diploid) break
}
}
plot(pr * 100, type = "b", col = "blue", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Tetraploid", ylim = c(0, 100), las = 1)
plot(pr_diploid * 100, type = "b", col = "red", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Diploid", ylim = c(0, 100), las = 1)
# Plot the success rate (pr) against heterozygote advantage
plot(pr * 100, type = "b", col = "blue", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Tetraploid vs Diploid", ylim = c(0, 100), las = 1)
# Add diploid success rate to the same plot
lines(pr_diploid * 100, type = "b", col = "red", pch = 16, lty = 2)
x_values <- (seltable[, 3] * 10)
axis(1, at = 1:length(x_values), labels = round(x_values, 1)) # Use rounded values from 3rd column
# Add gridlines for better readability
grid()
# Add legend
legend("bottomright", legend=c("Tetraploid", "Diploid"), col=c("blue", "red"), pch=c(15, 16), lty=c(1, 2))
# set some parameters to fixed values
init_RRRR <- 0
init_RRRr <- 0
init_RRrr <- 0
init_Rrrr <- 0
init_rrrr <- 250
mut_rate <- 0.01
max_gen <- 100
decay_rate <- 0.155
# determine how often to run the simulation for each set of parameters
replicates <- 500
#call the seltable here.
seltable <- create_sel_coeffs(s_number = 42, biggest_S = 3, inc = 0.005)
print(seltable)
# initialize vector - where to collect the probablitys
pr <- numeric(nrow(seltable))
# run the simulation across all chosen parameters
# loop over sel coefs tetraploid
for(i in 1:nrow(seltable)){
# loop over selection coefficients
sel_coeffs <- seltable[i, ]
j<-1
success <- 0
repeat {
j <- j+1
# increase counter by one
# run the simulation once
first_run <- simulate_pop_tetraploid(init_RRRR, init_RRRr, init_RRrr, init_Rrrr, init_rrrr, decay_rate, sel_coeffs, mut_rate, max_gen)
#complete cases to not take N/As we generated to fill the matrix
first_run_with_numbers <- first_run[complete.cases(first_run),]
#calculating total population size in the end
total_pop_in_the_end <- sum(as.numeric(first_run_with_numbers[nrow(first_run_with_numbers),]))
# determine if the population survived
if(total_pop_in_the_end != 0) {
success <- success + 1
}
pr[i] = success/replicates
if(j>=replicates) break
}
}
print(pr)
init_RR = 0
init_Rr = 0
init_rr = 250
pr_diploid <- numeric(nrow(seltable))
replicates_diploid <- 500
for(k in 1:nrow(seltable)){
# loop over selection coefficients
sel_coeffs <- seltable[k, ]
l<-1
success_diploid <- 0
repeat {
l <- l+1
# increase counter by one
# run the simulation once
first_run_diploid <- simulate_pop_diploid(init_RR, init_Rr, init_rr, decay_rate, sel_coeffs, mut_rate, max_gen)
#complete cases to not take N/As we generated to fill the matrix
first_run_with_numbers_diploid <- first_run_diploid[complete.cases(first_run_diploid),]
#calculating total population size in the end
total_pop_in_the_end_diploid <- sum(as.numeric(first_run_with_numbers_diploid[nrow(first_run_with_numbers_diploid),]))
# determine if the population survived
if(total_pop_in_the_end_diploid != 0) {
success_diploid <- success_diploid + 1
}
pr_diploid[k] = success_diploid/replicates_diploid
if(l>=replicates_diploid) break
}
}
plot(pr * 100, type = "b", col = "blue", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Tetraploid", ylim = c(0, 100), las = 1)
plot(pr_diploid * 100, type = "b", col = "red", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Diploid", ylim = c(0, 100), las = 1)
# Plot the success rate (pr) against heterozygote advantage
plot(pr * 100, type = "b", col = "blue", pch = 15, xlab = "Heterozygote Advantage",
ylab = "Success Rate(%)", main = "Tetraploid vs Diploid", ylim = c(0, 100), las = 1)
# Add diploid success rate to the same plot
lines(pr_diploid * 100, type = "b", col = "red", pch = 16, lty = 2)
x_values <- (seltable[, 3] * 10)
axis(1, at = 1:length(x_values), labels = round(x_values, 1)) # Use rounded values from 3rd column
# Add gridlines for better readability
grid()
# Add legend
legend("bottomright", legend=c("Tetraploid", "Diploid"), col=c("blue", "red"), pch=c(15, 16), lty=c(1, 2))
